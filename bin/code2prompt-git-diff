#!/usr/bin/env bash
# Generate a prompt.txt file with git diff and full codebase

set -euo pipefail

APP_ROOT="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"
cd "$APP_ROOT"

PROMPT_FILE="$APP_ROOT/prompt.txt"
TEMP_DIFF=$(mktemp)
TEMP_PROMPT=$(mktemp)

# Cleanup function
cleanup() {
  rm -f "$TEMP_DIFF" "$TEMP_PROMPT" "$TEMP_PROMPT.bak"
}
trap cleanup EXIT

# Start with the header
cat > "$TEMP_DIFF" << 'EOF'
You are a principal-level software reviewer. Analyze the git diff below and produce a precise, high-signal review focused on correctness, security, reliability, performance, and maintainability. This prompt is stack-agnostic and should work for any codebase.

Your job:
1) Read the DIFF carefully (don’t summarize the whole repo). Identify **bugs, security/privacy issues, design flaws, race conditions, misconfigurations, API misuse, performance footguns, test fragility, and code quality problems** introduced or revealed by the changes.
2) Be **diff-aware**: tie each finding to the exact changed lines/hunks. Prefer evidence from the diff over speculation.
3) When suggesting fixes, provide **minimal, correct patches** (unified diff snippets) and concrete test updates.

Deliverables (use this exact structure):

A) TOP RISKS (max 8 bullets)
- Each: **[Severity P1–P4] [Category] — one-liner**  
  (e.g., **P1 Security** Open redirect via `redirect_to params[:return]` without allowlist)

B) FINDINGS (sorted by severity, then area)
For each finding, include:
- **Title:** short & specific  
- **Severity:** P1 (critical) / P2 (high) / P3 (medium) / P4 (low)  
- **Scope:** file path(s) + smallest relevant hunk(s). Quote only essential lines from the diff.  
- **Why it’s a problem:** concrete failure modes, exploit paths, data loss, UX breakage, cost impact, etc.  
- **How to fix (actionable):** minimal steps or **ready-to-apply unified diff**. Prefer smallest safe change.  
- **Tests to add/update:** exact test names or new test skeletons; note determinism, edge cases, and fixtures.  
- **Blast radius:** what else might this touch (jobs, migrations, configs, caches), and rollback/mitigation steps.

C) ARCH/PRODUCT ALIGNMENT CHECKS (brief)
- Interfaces/Contracts: public API changes, backward compatibility, versioning.
- Concurrency/Idempotency: locks, retries, dedupe keys, timeouts, backoff.
- Data & Storage: migrations, schema/index changes, data correctness, retention.
- Config/ENV drift: new/renamed vars, defaults per env, secrets handling.
- Observability: logs (no sensitive leakage), metrics, alerts, tracing.
- Security: authn/z, input validation, XSS/CSRF/SSRF/command injection, least privilege.
- Performance/Cost: N+1s, memory, hot paths, I/O, caching, pagination limits.
- UX/Accessibility: broken flows, validation messages, keyboard/screen-reader basics.

D) QUICK WINS (≤10 minutes each)
- 3–10 tiny patches that reduce risk/noise immediately (lint, missing nil/None checks, logging, bounds, docstrings).

E) LONGER FIXES / REFACTOR CANDIDATES
- 3–8 items with rationale and a small plan (1–3 steps each). Prioritize high ROI/low coupling.

F) DIFF PATCHES
- Include the most impactful **unified diff** patches for P1/P2 findings (minimal, isolated).

G) REGRESSION RISKS & MONITORING
- Top 5 things likely to break post-merge and how to detect them (exact log lines/metrics/alerts to add).

Heuristics & nitpicks to apply while reviewing (generic):
- **Diff hygiene:** dead code, TODOs, commented-out blocks, debug prints, inconsistent naming.
- **Error handling:** propagated vs swallowed errors, retries vs fail-fast, user-visible messages.
- **Input/output validation:** type/shape checks, length/range, encoding, locale/timezone, nullability.
- **API/SDK use:** correct methods, pagination, rate limits, idempotency keys, status/exception handling.
- **Resource mgmt:** file/socket/DB handle leaks, connection pools, thread/process safety.
- **Security & privacy:** secret exposure, PII in logs, insecure defaults, permissive CORS, plaintext storage.
- **Testing:** coverage of negative paths, flakiness (timers/sleeps), global state, fixture coupling.
- **Docs & ops:** env var docs, runbooks, migration instructions, feature flags and rollback plan.

Output rules:
- Be blunt and specific. No generic advice. Tie every claim to the diff.
- Show patches as unified diffs. Keep them minimal.
- When uncertain, state the uncertainty and what evidence would resolve it.

Now, analyze this diff:

EOF

# Get all changes (staged + unstaged) in one diff
git diff HEAD >> "$TEMP_DIFF" 2>/dev/null || true

# Get untracked files and format them as diff additions
UNTRACKED=$(git ls-files --others --exclude-standard)
if [ -n "$UNTRACKED" ]; then
  for file in $UNTRACKED; do
    echo "" >> "$TEMP_DIFF"
    echo "diff --git a/$file b/$file" >> "$TEMP_DIFF"
    echo "new file mode 100644" >> "$TEMP_DIFF"
    echo "index 0000000..$(git hash-object "$file" 2>/dev/null | cut -c1-7 2>/dev/null || echo "0000000")" >> "$TEMP_DIFF"
    echo "--- /dev/null" >> "$TEMP_DIFF"
    echo "+++ b/$file" >> "$TEMP_DIFF"
    echo "@@ -0,0 +1,$(wc -l < "$file" 2>/dev/null || echo "0") @@" >> "$TEMP_DIFF"
    # Add file content with + prefix
    sed 's/^/+/' "$file" >> "$TEMP_DIFF" 2>/dev/null || echo "+$(cat "$file" 2>/dev/null || echo "(could not read file)")" >> "$TEMP_DIFF"
  done
fi

# Generate full codebase using code2prompt to a temp file
code2prompt . "$TEMP_PROMPT" \
  --exclude "prompt.txt" \
  --quiet 2>/dev/null || {
  echo "Warning: code2prompt command failed, trying bin/code2prompt..." >&2
  # Fallback: try running bin/code2prompt and capture its output
  # Since bin/code2prompt writes to prompt.txt, we need to work around this
  if [ -f "$PROMPT_FILE" ]; then
    mv "$PROMPT_FILE" "$TEMP_PROMPT.bak"
  fi
  "$APP_ROOT/bin/code2prompt" >/dev/null 2>&1 || true
  if [ -f "$PROMPT_FILE" ]; then
    mv "$PROMPT_FILE" "$TEMP_PROMPT"
    if [ -f "$TEMP_PROMPT.bak" ]; then
      rm -f "$TEMP_PROMPT.bak"
    fi
  else
    echo "(code2prompt output unavailable)" > "$TEMP_PROMPT"
  fi
}

# Combine everything into prompt.txt
cat "$TEMP_DIFF" > "$PROMPT_FILE"
cat >> "$PROMPT_FILE" << 'EOF'

Full code:



EOF
cat "$TEMP_PROMPT" >> "$PROMPT_FILE"

echo "✓ Generated prompt.txt with git diff and full codebase"

